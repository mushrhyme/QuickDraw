<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QuickDraw Drawing Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        canvas {
            border: 2px solid #333;
            cursor: crosshair;
            background-color: white;
        }
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #4CAF50;
            color: white;
        }
        button:hover {
            background-color: #45a049;
        }
        button#clearBtn {
            background-color: #f44336;
        }
        button#clearBtn:hover {
            background-color: #da190b;
        }
    </style>
</head>
<body>
    <h1>QuickDraw Drawing Test</h1>
    <div style="margin-bottom: 10px; color: #666; font-size: 14px;">
        ğŸ’¡ íŒ: ë¹ ë¥´ê²Œ ê·¸ë¦¬ê³ , ìì£¼ ì†ì„ ë–¼ì–´ ì—¬ëŸ¬ ìŠ¤íŠ¸ë¡œí¬ë¡œ ê·¸ë¦¬ì„¸ìš”!<br>
        í•™ìŠµ ë°ì´í„°ëŠ” ë³´í†µ <strong>3-5ê°œì˜ ìŠ¤íŠ¸ë¡œí¬</strong>ì™€ <strong>30-70ê°œì˜ í¬ì¸íŠ¸</strong>ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤.<br>
        í¬ì¸íŠ¸ëŠ” ìë™ìœ¼ë¡œ ìƒ˜í”Œë§ë˜ì–´ ê¸°ë¡ë©ë‹ˆë‹¤ (ê±°ë¦¬ 12px ì´ìƒ, ì‹œê°„ 30ms ì´ìƒ ê°„ê²©).
    </div>
    <canvas id="drawingCanvas" width="500" height="500"></canvas>
    <div class="controls">
        <button id="clearBtn">Clear</button>
        <button id="exportBtn">Export JSON</button>
    </div>
    <div id="stats" style="margin-top: 10px; color: #666; font-size: 12px;"></div>

    <script>
        // ìº”ë²„ìŠ¤ ë° ì»¨í…ìŠ¤íŠ¸ ì„¤ì •
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        
        // QuickDraw í˜•ì‹ ë°ì´í„° êµ¬ì¡°: [[[x0,x1,...], [y0,y1,...]], [[...],[...]], ...]
        let drawing = [];
        let currentStroke = null;  // í˜„ì¬ ìŠ¤íŠ¸ë¡œí¬: {x: [], y: []}
        let isDrawing = false;     // ê·¸ë¦¬ê¸° ì¤‘ì¸ì§€ ì—¬ë¶€

        // ìº”ë²„ìŠ¤ ì´ˆê¸°í™” (í°ìƒ‰ ë°°ê²½)
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // ë§ˆìš°ìŠ¤ ë‹¤ìš´ ì´ë²¤íŠ¸ - ìƒˆ ìŠ¤íŠ¸ë¡œí¬ ì‹œì‘
        canvas.addEventListener('mousedown', (e) => {
            // ì´ì „ ìŠ¤íŠ¸ë¡œí¬ê°€ ì¼ì • ì‹œê°„ ì§€ë‚˜ë©´ ìë™ìœ¼ë¡œ ëŠê¸°
            if (lastStrokeTime && Date.now() - lastStrokeTime > STROKE_TIMEOUT && currentStroke) {
                drawing.push([currentStroke.x, currentStroke.y]);
                currentStroke = null;
            }
            
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;  // ìº”ë²„ìŠ¤ ì¢Œí‘œê³„ë¡œ ë³€í™˜
            const y = e.clientY - rect.top;
            
            // ìƒˆ ìŠ¤íŠ¸ë¡œí¬ ì‹œì‘
            currentStroke = {
                x: [x],
                y: [y]
            };
            
            // ì´ˆê¸°í™”
            lastRecordedX = x;
            lastRecordedY = y;
            lastRecordedTime = Date.now();
            lastStrokeTime = Date.now();
            
            // ê²½ë¡œ ì‹œì‘
            ctx.beginPath();
            ctx.moveTo(x, y);
        });

        // í¬ì¸íŠ¸ ìƒ˜í”Œë§ ì„¤ì • (í•™ìŠµ ë°ì´í„°ì™€ ìœ ì‚¬í•˜ê²Œ)
        const MIN_DISTANCE = 12;  // ìµœì†Œ ê±°ë¦¬ (í”½ì…€) - ì´ ê±°ë¦¬ ì´ìƒ ì´ë™í•´ì•¼ í¬ì¸íŠ¸ ê¸°ë¡
        const MIN_TIME_INTERVAL = 30;  // ìµœì†Œ ì‹œê°„ ê°„ê²© (ms) - ì´ ì‹œê°„ ì´ìƒ ì§€ë‚˜ì•¼ í¬ì¸íŠ¸ ê¸°ë¡
        let lastRecordedX = null;
        let lastRecordedY = null;
        let lastRecordedTime = null;
        let lastStrokeTime = null;
        const STROKE_TIMEOUT = 200;  // 200ms ë™ì•ˆ ê·¸ë¦¬ì§€ ì•Šìœ¼ë©´ ìŠ¤íŠ¸ë¡œí¬ ìë™ ëŠê¹€

        // ë§ˆìš°ìŠ¤ ì´ë™ ì´ë²¤íŠ¸ - ìŠ¤íŠ¸ë¡œí¬ ê¸°ë¡ ë° ê·¸ë¦¬ê¸°
        canvas.addEventListener('mousemove', (e) => {
            if (!isDrawing || !currentStroke) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;  // ìº”ë²„ìŠ¤ ì¢Œí‘œê³„ë¡œ ë³€í™˜
            const y = e.clientY - rect.top;
            const currentTime = Date.now();
            
            // ì„ ì€ í•­ìƒ ê·¸ë¦¬ê¸° (ì‹œê°ì  í”¼ë“œë°±)
            ctx.lineTo(x, y);
            ctx.stroke();
            
            // í¬ì¸íŠ¸ ê¸°ë¡ ì¡°ê±´: ê±°ë¦¬ AND ì‹œê°„ ëª¨ë‘ ë§Œì¡±í•´ì•¼ í•¨
            let shouldRecord = false;
            if (lastRecordedX === null || lastRecordedY === null || lastRecordedTime === null) {
                // ì²« í¬ì¸íŠ¸ëŠ” í•­ìƒ ê¸°ë¡
                shouldRecord = true;
            } else {
                const distance = Math.sqrt(
                    Math.pow(x - lastRecordedX, 2) + Math.pow(y - lastRecordedY, 2)
                );
                const timeElapsed = currentTime - lastRecordedTime;
                
                // ê±°ë¦¬ì™€ ì‹œê°„ ëª¨ë‘ ì¡°ê±´ì„ ë§Œì¡±í•´ì•¼ ê¸°ë¡
                if (distance >= MIN_DISTANCE && timeElapsed >= MIN_TIME_INTERVAL) {
                    shouldRecord = true;
                }
            }
            
            // í¬ì¸íŠ¸ëŠ” ì¡°ê±´ë¶€ë¡œë§Œ ê¸°ë¡ (ë„ì—„ë„ì—„)
            if (shouldRecord) {
                currentStroke.x.push(x);
                currentStroke.y.push(y);
                lastRecordedX = x;
                lastRecordedY = y;
                lastRecordedTime = currentTime;
                lastStrokeTime = currentTime;
            }
        });

        // í†µê³„ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        function updateStats() {
            let totalStrokes = drawing.length + (currentStroke ? 1 : 0);
            let totalPoints = 0;
            for (let stroke of drawing) {
                totalPoints += stroke[0].length;
            }
            if (currentStroke) {
                totalPoints += currentStroke.x.length;
            }
            document.getElementById('stats').textContent = 
                `ìŠ¤íŠ¸ë¡œí¬: ${totalStrokes} | í¬ì¸íŠ¸: ${totalPoints}`;
        }

        // ë§ˆìš°ìŠ¤ ì—… ì´ë²¤íŠ¸ - ìŠ¤íŠ¸ë¡œí¬ ì™„ë£Œ
        canvas.addEventListener('mouseup', () => {
            if (isDrawing && currentStroke) {
                // í˜„ì¬ ìŠ¤íŠ¸ë¡œí¬ë¥¼ drawing ë°°ì—´ì— ì¶”ê°€
                drawing.push([currentStroke.x, currentStroke.y]);
                currentStroke = null;
                lastRecordedX = null;
                lastRecordedY = null;
                lastRecordedTime = null;
                updateStats();
            }
            isDrawing = false;
        });

        // ë§ˆìš°ìŠ¤ê°€ ìº”ë²„ìŠ¤ ë°–ìœ¼ë¡œ ë‚˜ê°ˆ ë•Œë„ ìŠ¤íŠ¸ë¡œí¬ ì¢…ë£Œ
        canvas.addEventListener('mouseleave', () => {
            if (isDrawing && currentStroke) {
                drawing.push([currentStroke.x, currentStroke.y]);
                currentStroke = null;
                lastRecordedX = null;
                lastRecordedY = null;
                lastRecordedTime = null;
                updateStats();
            }
            isDrawing = false;
        });
        
        // ì´ˆê¸° í†µê³„ í‘œì‹œ
        updateStats();

        // Clear ë²„íŠ¼ - ìº”ë²„ìŠ¤ ë° ìŠ¤íŠ¸ë¡œí¬ ì´ˆê¸°í™”
        document.getElementById('clearBtn').addEventListener('click', () => {
            // ìº”ë²„ìŠ¤ ì§€ìš°ê¸°
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // ìŠ¤íŠ¸ë¡œí¬ ë°ì´í„° ì´ˆê¸°í™”
            drawing = [];
            currentStroke = null;
            isDrawing = false;
            lastRecordedX = null;
            lastRecordedY = null;
            lastRecordedTime = null;
            lastStrokeTime = null;
        });

        // ìŠ¤íŠ¸ë¡œí¬ ë‹¤ìš´ìƒ˜í”Œë§ í•¨ìˆ˜ (ë„ˆë¬´ ë§ì€ í¬ì¸íŠ¸ê°€ ìˆìœ¼ë©´ ì¤„ì´ê¸°)
        function downsampleStroke(stroke, maxPoints = 30) {
            if (stroke[0].length <= maxPoints) return stroke;
            
            const x = stroke[0];
            const y = stroke[1];
            const step = Math.ceil(x.length / maxPoints);
            
            const downsampledX = [];
            const downsampledY = [];
            
            // ì²« í¬ì¸íŠ¸ì™€ ë§ˆì§€ë§‰ í¬ì¸íŠ¸ëŠ” í•­ìƒ í¬í•¨
            downsampledX.push(x[0]);
            downsampledY.push(y[0]);
            
            // ì¤‘ê°„ í¬ì¸íŠ¸ë“¤ì„ ê°„ê²©ì„ ë‘ê³  ì„ íƒ
            for (let i = step; i < x.length - 1; i += step) {
                downsampledX.push(x[i]);
                downsampledY.push(y[i]);
            }
            
            // ë§ˆì§€ë§‰ í¬ì¸íŠ¸
            downsampledX.push(x[x.length - 1]);
            downsampledY.push(y[y.length - 1]);
            
            return [downsampledX, downsampledY];
        }

        // ì¢Œí‘œë¥¼ 0-255 ë²”ìœ„ë¡œ ì •ê·œí™”í•˜ëŠ” í•¨ìˆ˜
        function normalizeDrawing(drawing) {
            if (drawing.length === 0) return drawing;
            
            // ë¨¼ì € ê° ìŠ¤íŠ¸ë¡œí¬ë¥¼ ë‹¤ìš´ìƒ˜í”Œë§ (ë„ˆë¬´ ë§ì€ í¬ì¸íŠ¸ ì¤„ì´ê¸°)
            const downsampled = drawing.map(stroke => downsampleStroke(stroke, 30));
            
            // ëª¨ë“  ì¢Œí‘œ ìˆ˜ì§‘
            let allX = [];
            let allY = [];
            for (let stroke of downsampled) {
                allX = allX.concat(stroke[0]);
                allY = allY.concat(stroke[1]);
            }
            
            if (allX.length === 0) return drawing;
            
            // ë²”ìœ„ ê³„ì‚°
            const xMin = Math.min(...allX);
            const xMax = Math.max(...allX);
            const yMin = Math.min(...allY);
            const yMax = Math.max(...allY);
            
            const xRange = xMax - xMin || 1;
            const yRange = yMax - yMin || 1;
            
            // ì •ê·œí™”ëœ drawing ìƒì„±
            const normalized = [];
            for (let stroke of downsampled) {
                const normX = stroke[0].map(x => Math.round((x - xMin) / xRange * 255));
                const normY = stroke[1].map(y => Math.round((y - yMin) / yRange * 255));
                normalized.push([normX, normY]);
            }
            
            return normalized;
        }

        // Export JSON ë²„íŠ¼ - drawing.json ë‹¤ìš´ë¡œë“œ
        document.getElementById('exportBtn').addEventListener('click', () => {
            // ë§ˆì§€ë§‰ ìŠ¤íŠ¸ë¡œí¬ë„ ì¶”ê°€
            if (currentStroke) {
                drawing.push([currentStroke.x, currentStroke.y]);
                currentStroke = null;
            }
            
            // ì¢Œí‘œ ì •ê·œí™” (0-255 ë²”ìœ„)
            const normalizedDrawing = normalizeDrawing(drawing);
            
            // JSON êµ¬ì¡° ìƒì„±: { "drawing": [...] }
            const jsonData = {
                drawing: normalizedDrawing
            };
            
            // JSON ë¬¸ìì—´ë¡œ ë³€í™˜
            const jsonString = JSON.stringify(jsonData, null, 2);
            
            // Blob ìƒì„± ë° ë‹¤ìš´ë¡œë“œ
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'drawing.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            // í†µê³„ ì¶œë ¥
            let totalPoints = 0;
            for (let stroke of normalizedDrawing) {
                totalPoints += stroke[0].length;
            }
            console.log(`ìŠ¤íŠ¸ë¡œí¬ ìˆ˜: ${normalizedDrawing.length}`);
            console.log(`ì´ í¬ì¸íŠ¸ ìˆ˜: ${totalPoints}`);
            alert(`Export ì™„ë£Œ!\nìŠ¤íŠ¸ë¡œí¬ ìˆ˜: ${normalizedDrawing.length}\nì´ í¬ì¸íŠ¸ ìˆ˜: ${totalPoints}`);
        });
    </script>
</body>
</html>

